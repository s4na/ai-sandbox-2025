<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>æ¶ç©ºã®ç”»åƒãƒˆãƒªãƒŸãƒ³ã‚°ãƒ„ãƒ¼ãƒ« - 10MBæœ€é©åŒ–ãƒ“ãƒ¥ãƒ¼ãƒ¯ãƒ¼</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 20px;
        }
        
        .container {
            background: white;
            border-radius: 20px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
            max-width: 1200px;
            width: 100%;
            padding: 30px;
        }
        
        h1 {
            text-align: center;
            color: #333;
            margin-bottom: 10px;
            font-size: 28px;
        }
        
        .subtitle {
            text-align: center;
            color: #666;
            margin-bottom: 30px;
            font-size: 14px;
        }
        
        .drop-zone {
            border: 3px dashed #667eea;
            border-radius: 15px;
            padding: 40px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s ease;
            background: #f8f9ff;
            margin-bottom: 30px;
        }
        
        .drop-zone.dragover {
            background: #e8ebff;
            border-color: #764ba2;
            transform: scale(1.02);
        }
        
        .drop-zone.hidden {
            display: none;
        }
        
        .drop-icon {
            font-size: 60px;
            color: #667eea;
            margin-bottom: 20px;
        }
        
        .drop-text {
            color: #666;
            font-size: 18px;
            margin-bottom: 10px;
        }
        
        .drop-subtext {
            color: #999;
            font-size: 14px;
        }
        
        .editor-container {
            display: none;
            position: relative;
        }
        
        .editor-container.active {
            display: block;
        }
        
        .toolbar {
            background: #f5f5f5;
            padding: 15px;
            border-radius: 10px;
            margin-bottom: 20px;
            display: flex;
            gap: 15px;
            flex-wrap: wrap;
            align-items: center;
        }
        
        .btn {
            padding: 10px 20px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 600;
            transition: all 0.3s ease;
            color: white;
        }
        
        .btn-primary {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        }
        
        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.4);
        }
        
        .btn-secondary {
            background: #6c757d;
        }
        
        .btn-secondary:hover {
            background: #5a6268;
        }
        
        .btn-success {
            background: #28a745;
        }
        
        .btn-success:hover {
            background: #218838;
        }
        
        .btn-warning {
            background: #ffc107;
            color: #333;
        }
        
        .btn-warning:hover {
            background: #e0a800;
        }
        
        .canvas-container {
            position: relative;
            background: #f0f0f0;
            border-radius: 10px;
            padding: 20px;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 400px;
        }
        
        #canvas {
            max-width: 100%;
            border: 1px solid #ddd;
            cursor: crosshair;
            background: white;
        }
        
        .size-display {
            position: fixed;
            bottom: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 15px 20px;
            border-radius: 10px;
            font-size: 14px;
            z-index: 1000;
            min-width: 200px;
        }
        
        .size-info {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }
        
        .size-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .size-label {
            color: #aaa;
            font-size: 12px;
        }
        
        .size-value {
            font-weight: bold;
            font-size: 16px;
        }
        
        .size-progress {
            width: 100%;
            height: 4px;
            background: #444;
            border-radius: 2px;
            overflow: hidden;
            margin-top: 8px;
        }
        
        .size-progress-bar {
            height: 100%;
            background: linear-gradient(90deg, #28a745, #ffc107, #dc3545);
            transition: width 0.3s ease;
        }
        
        .crop-overlay {
            position: absolute;
            border: 3px dashed #667eea;
            background: rgba(102, 126, 234, 0.15);
            pointer-events: none;
            box-shadow: 0 0 0 9999px rgba(0, 0, 0, 0.5);
            animation: pulse 1s ease-in-out infinite;
        }
        
        @keyframes pulse {
            0%, 100% { border-color: #667eea; }
            50% { border-color: #764ba2; }
        }
        
        .crop-handle {
            position: absolute;
            width: 10px;
            height: 10px;
            background: white;
            border: 2px solid #667eea;
            border-radius: 50%;
        }
        
        .crop-handle.nw { top: -5px; left: -5px; cursor: nw-resize; }
        .crop-handle.ne { top: -5px; right: -5px; cursor: ne-resize; }
        .crop-handle.sw { bottom: -5px; left: -5px; cursor: sw-resize; }
        .crop-handle.se { bottom: -5px; right: -5px; cursor: se-resize; }
        
        .input-group {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .input-group label {
            font-size: 14px;
            color: #666;
            white-space: nowrap;
        }
        
        .input-group input {
            padding: 8px 12px;
            border: 1px solid #ddd;
            border-radius: 6px;
            font-size: 14px;
            width: 100px;
        }
        
        .quality-slider {
            display: flex;
            align-items: center;
            gap: 10px;
            flex: 1;
        }
        
        .quality-slider input[type="range"] {
            flex: 1;
        }
        
        .quality-value {
            min-width: 40px;
            text-align: center;
            font-weight: bold;
            color: #667eea;
        }
        
        input[type="file"] {
            display: none;
        }
        
        .crop-mode-indicator {
            position: fixed;
            top: 20px;
            right: 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 12px 24px;
            border-radius: 30px;
            font-weight: bold;
            z-index: 1000;
            display: none;
            animation: slideIn 0.3s ease;
            box-shadow: 0 4px 15px rgba(102, 126, 234, 0.4);
        }
        
        .crop-mode-indicator.active {
            display: block;
        }
        
        @keyframes slideIn {
            from {
                transform: translateX(100%);
                opacity: 0;
            }
            to {
                transform: translateX(0);
                opacity: 1;
            }
        }
        
        .crop-instructions {
            position: fixed;
            bottom: 80px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.9);
            color: white;
            padding: 15px 30px;
            border-radius: 10px;
            font-size: 14px;
            z-index: 1000;
            display: none;
            animation: fadeIn 0.5s ease;
        }
        
        .crop-instructions.active {
            display: block;
        }
        
        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>ğŸ–¼ï¸ æ¶ç©ºã®ç”»åƒãƒˆãƒªãƒŸãƒ³ã‚°ãƒ„ãƒ¼ãƒ«</h1>
        <p class="subtitle">10MBæœ€é©åŒ–ãƒ“ãƒ¥ãƒ¼ãƒ¯ãƒ¼ - ãƒ‰ãƒ©ãƒƒã‚°&ãƒ‰ãƒ­ãƒƒãƒ—ã§ç°¡å˜ãƒˆãƒªãƒŸãƒ³ã‚°</p>
        
        <div class="drop-zone" id="dropZone">
            <div class="drop-icon">ğŸ“¸</div>
            <div class="drop-text">ç”»åƒã‚’ãƒ‰ãƒ©ãƒƒã‚°&ãƒ‰ãƒ­ãƒƒãƒ—</div>
            <div class="drop-subtext">ã¾ãŸã¯ ã‚¯ãƒªãƒƒã‚¯ã—ã¦ãƒ•ã‚¡ã‚¤ãƒ«ã‚’é¸æŠ</div>
            <input type="file" id="fileInput" accept="image/*">
        </div>
        
        <div class="editor-container" id="editorContainer">
            <div class="toolbar">
                <button class="btn btn-primary" id="cropFreeBtn">è‡ªç”±ã‚µã‚¤ã‚ºã§ãƒˆãƒªãƒŸãƒ³ã‚°</button>
                <button class="btn btn-warning" id="crop10MBBtn">10MBã¡ã‚‡ã†ã©ã«ãƒˆãƒªãƒŸãƒ³ã‚°</button>
                <button class="btn btn-success" id="downloadBtn">ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰</button>
                <button class="btn btn-secondary" id="resetBtn">ãƒªã‚»ãƒƒãƒˆ</button>
                <button class="btn btn-secondary" id="newImageBtn">åˆ¥ã®ç”»åƒã‚’é¸æŠ</button>
                
                <div class="quality-slider">
                    <label>å“è³ª:</label>
                    <input type="range" id="qualitySlider" min="10" max="100" value="85">
                    <span class="quality-value" id="qualityValue">85</span>
                </div>
                
                <div class="input-group">
                    <label>å¹…:</label>
                    <input type="number" id="widthInput" min="1">
                    <label>é«˜ã•:</label>
                    <input type="number" id="heightInput" min="1">
                </div>
            </div>
            
            <div class="canvas-container">
                <canvas id="canvas"></canvas>
                <div class="crop-overlay" id="cropOverlay" style="display: none;">
                    <div class="crop-handle nw"></div>
                    <div class="crop-handle ne"></div>
                    <div class="crop-handle sw"></div>
                    <div class="crop-handle se"></div>
                </div>
            </div>
        </div>
    </div>
    
    <div class="size-display" id="sizeDisplay" style="display: none;">
        <div class="size-info">
            <div class="size-row">
                <span class="size-label">ç¾åœ¨ã®ã‚µã‚¤ã‚º:</span>
                <span class="size-value" id="currentSize">0 MB</span>
            </div>
            <div class="size-row">
                <span class="size-label">ç›®æ¨™:</span>
                <span style="color: #28a745;">10 MB</span>
            </div>
            <div class="size-row">
                <span class="size-label">è§£åƒåº¦:</span>
                <span id="resolution">0 x 0</span>
            </div>
            <div class="size-progress">
                <div class="size-progress-bar" id="sizeProgressBar"></div>
            </div>
        </div>
    </div>
    
    <div class="crop-mode-indicator" id="cropModeIndicator">
        ğŸ¯ ãƒˆãƒªãƒŸãƒ³ã‚°ãƒ¢ãƒ¼ãƒ‰
    </div>
    
    <div class="crop-instructions" id="cropInstructions">
        ğŸ“ ãƒã‚¦ã‚¹ã§ãƒ‰ãƒ©ãƒƒã‚°ã—ã¦ç¯„å›²ã‚’é¸æŠã—ã¦ãã ã•ã„
    </div>
    
    <script>
        class ImageTrimmer {
            constructor() {
                this.originalImage = null;
                this.currentImage = null;
                this.beforeCropImage = null;
                this.canvas = document.getElementById('canvas');
                this.ctx = this.canvas.getContext('2d');
                this.cropArea = null;
                this.isDragging = false;
                this.isCropMode = false;
                this.isShowingOriginal = false;
                this.dragStart = null;
                this.quality = 0.85;
                
                this.initEventListeners();
            }
            
            initEventListeners() {
                const dropZone = document.getElementById('dropZone');
                const fileInput = document.getElementById('fileInput');
                
                // ãƒ‰ãƒ©ãƒƒã‚°&ãƒ‰ãƒ­ãƒƒãƒ—
                dropZone.addEventListener('dragover', (e) => {
                    e.preventDefault();
                    dropZone.classList.add('dragover');
                });
                
                dropZone.addEventListener('dragleave', () => {
                    dropZone.classList.remove('dragover');
                });
                
                dropZone.addEventListener('drop', (e) => {
                    e.preventDefault();
                    dropZone.classList.remove('dragover');
                    const files = e.dataTransfer.files;
                    if (files.length > 0 && files[0].type.startsWith('image/')) {
                        this.loadImage(files[0]);
                    }
                });
                
                dropZone.addEventListener('click', () => {
                    fileInput.click();
                });
                
                fileInput.addEventListener('change', (e) => {
                    if (e.target.files.length > 0) {
                        this.loadImage(e.target.files[0]);
                    }
                });
                
                // ãƒœã‚¿ãƒ³ã‚¤ãƒ™ãƒ³ãƒˆ
                document.getElementById('cropFreeBtn').addEventListener('click', () => {
                    this.startFreeCrop();
                });
                
                document.getElementById('crop10MBBtn').addEventListener('click', () => {
                    this.startSmartCrop10MB();
                });
                
                document.getElementById('downloadBtn').addEventListener('click', () => {
                    this.downloadImage();
                });
                
                document.getElementById('resetBtn').addEventListener('click', () => {
                    this.resetImage();
                });
                
                document.getElementById('newImageBtn').addEventListener('click', () => {
                    this.selectNewImage();
                });
                
                // å“è³ªã‚¹ãƒ©ã‚¤ãƒ€ãƒ¼
                const qualitySlider = document.getElementById('qualitySlider');
                qualitySlider.addEventListener('input', (e) => {
                    this.quality = e.target.value / 100;
                    document.getElementById('qualityValue').textContent = e.target.value;
                    this.updateSizeDisplay();
                });
                
                // ã‚µã‚¤ã‚ºå…¥åŠ›
                document.getElementById('widthInput').addEventListener('input', () => {
                    this.resizeCanvas();
                });
                
                document.getElementById('heightInput').addEventListener('input', () => {
                    this.resizeCanvas();
                });
                
                // ã‚­ãƒ£ãƒ³ãƒã‚¹ãƒã‚¦ã‚¹ã‚¤ãƒ™ãƒ³ãƒˆ
                this.canvas.addEventListener('mousedown', (e) => this.startCrop(e));
                this.canvas.addEventListener('mousemove', (e) => this.updateCrop(e));
                this.canvas.addEventListener('mouseup', () => this.endCrop());
                this.canvas.addEventListener('mouseleave', () => this.endCrop());
            }
            
            loadImage(file) {
                const reader = new FileReader();
                reader.onload = (e) => {
                    const img = new Image();
                    img.onload = () => {
                        this.originalImage = img;
                        this.currentImage = img;
                        this.displayImage(img);
                        this.showEditor();
                    };
                    img.src = e.target.result;
                };
                reader.readAsDataURL(file);
            }
            
            displayImage(img) {
                console.log(`displayImage called - Original size: ${img.width}x${img.height}`);
                
                const maxWidth = 800;
                const maxHeight = 600;
                let displayWidth = img.width;
                let displayHeight = img.height;
                
                // è¡¨ç¤ºç”¨ã®ã‚µã‚¤ã‚ºã‚’è¨ˆç®—ï¼ˆã‚­ãƒ£ãƒ³ãƒã‚¹ã¯è¡¨ç¤ºç”¨ï¼‰
                if (displayWidth > maxWidth) {
                    displayHeight = (maxWidth / displayWidth) * displayHeight;
                    displayWidth = maxWidth;
                }
                if (displayHeight > maxHeight) {
                    displayWidth = (maxHeight / displayHeight) * displayWidth;
                    displayHeight = maxHeight;
                }
                
                console.log(`Canvas display size: ${displayWidth}x${displayHeight}`);
                
                this.canvas.width = displayWidth;
                this.canvas.height = displayHeight;
                this.ctx.drawImage(img, 0, 0, displayWidth, displayHeight);
                
                // å…¥åŠ›ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã«ã¯å®Ÿéš›ã®ç”»åƒã‚µã‚¤ã‚ºã‚’è¡¨ç¤º
                document.getElementById('widthInput').value = Math.round(img.width);
                document.getElementById('heightInput').value = Math.round(img.height);
                
                this.updateSizeDisplay();
            }
            
            showEditor() {
                document.getElementById('dropZone').classList.add('hidden');
                document.getElementById('editorContainer').classList.add('active');
                document.getElementById('sizeDisplay').style.display = 'block';
            }
            
            hideEditor() {
                document.getElementById('dropZone').classList.remove('hidden');
                document.getElementById('editorContainer').classList.remove('active');
                document.getElementById('sizeDisplay').style.display = 'none';
            }
            
            startFreeCrop() {
                this.cropArea = null;
                this.isCropMode = true;
                document.getElementById('cropOverlay').style.display = 'none';
                document.getElementById('cropModeIndicator').classList.add('active');
                document.getElementById('cropInstructions').classList.add('active');
                this.canvas.style.cursor = 'crosshair';
                
                // ç¢ºå®šãƒœã‚¿ãƒ³ã¨ã‚­ãƒ£ãƒ³ã‚»ãƒ«ãƒœã‚¿ãƒ³ã‚’è¡¨ç¤º
                this.showCropControls();
            }
            
            startCrop(e) {
                if (!this.currentImage || !this.isCropMode) return;
                
                const rect = this.canvas.getBoundingClientRect();
                this.isDragging = true;
                this.dragStart = {
                    x: e.clientX - rect.left,
                    y: e.clientY - rect.top
                };
                
                const overlay = document.getElementById('cropOverlay');
                overlay.style.display = 'block';
                overlay.style.left = this.dragStart.x + 'px';
                overlay.style.top = this.dragStart.y + 'px';
                overlay.style.width = '0px';
                overlay.style.height = '0px';
                
                // æŒ‡ç¤ºã‚’æ›´æ–°
                document.getElementById('cropInstructions').textContent = 'ğŸ“ ç¯„å›²ã‚’èª¿æ•´ä¸­... ãƒ‰ãƒ©ãƒƒã‚°ã—ã¦ç¯„å›²ã‚’æŒ‡å®š';
            }
            
            updateCrop(e) {
                if (!this.isDragging || !this.dragStart) return;
                
                const rect = this.canvas.getBoundingClientRect();
                const currentX = e.clientX - rect.left;
                const currentY = e.clientY - rect.top;
                
                const width = Math.abs(currentX - this.dragStart.x);
                const height = Math.abs(currentY - this.dragStart.y);
                const left = Math.min(currentX, this.dragStart.x);
                const top = Math.min(currentY, this.dragStart.y);
                
                const overlay = document.getElementById('cropOverlay');
                overlay.style.left = left + 'px';
                overlay.style.top = top + 'px';
                overlay.style.width = width + 'px';
                overlay.style.height = height + 'px';
                
                this.cropArea = { left, top, width, height };
                this.updateCropSizeDisplay();
            }
            
            endCrop() {
                this.isDragging = false;
                if (this.cropArea && this.cropArea.width > 10 && this.cropArea.height > 10) {
                    // ç¯„å›²é¸æŠå®Œäº†ã€ç¢ºå®šå¾…ã¡
                    document.getElementById('cropInstructions').innerHTML = 
                        'âœ… ç¯„å›²é¸æŠå®Œäº†ï¼<br>ã€ŒãƒˆãƒªãƒŸãƒ³ã‚°ç¢ºå®šã€ãƒœã‚¿ãƒ³ã§å®Ÿè¡Œ or ã€Œã‚­ãƒ£ãƒ³ã‚»ãƒ«ã€ã§ä¸­æ­¢';
                    this.showCropButtons();
                }
            }
            
            showCropControls() {
                // æ—¢å­˜ã®ãƒœã‚¿ãƒ³ã‚’éè¡¨ç¤º
                const existingButtons = document.getElementById('cropControlButtons');
                if (existingButtons) {
                    existingButtons.remove();
                }
            }
            
            showCropButtons() {
                // æ—¢å­˜ã®ãƒœã‚¿ãƒ³ã‚’å‰Šé™¤
                const existingButtons = document.getElementById('cropControlButtons');
                if (existingButtons) {
                    existingButtons.remove();
                }
                
                // æ–°ã—ã„ãƒœã‚¿ãƒ³ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ«ã‚’ä½œæˆ
                const controlDiv = document.createElement('div');
                controlDiv.id = 'cropControlButtons';
                controlDiv.style.cssText = `
                    position: fixed;
                    bottom: 140px;
                    left: 50%;
                    transform: translateX(-50%);
                    display: flex;
                    gap: 15px;
                    z-index: 1001;
                `;
                
                const confirmBtn = document.createElement('button');
                confirmBtn.textContent = 'âœ‚ï¸ ãƒˆãƒªãƒŸãƒ³ã‚°ç¢ºå®š';
                confirmBtn.className = 'btn btn-success';
                confirmBtn.onclick = () => this.confirmCrop();
                
                const cancelBtn = document.createElement('button');
                cancelBtn.textContent = 'âŒ ã‚­ãƒ£ãƒ³ã‚»ãƒ«';
                cancelBtn.className = 'btn btn-secondary';
                cancelBtn.onclick = () => this.cancelCrop();
                
                controlDiv.appendChild(confirmBtn);
                controlDiv.appendChild(cancelBtn);
                document.body.appendChild(controlDiv);
            }
            
            confirmCrop() {
                if (!this.cropArea) return;
                
                // å…ƒç”»åƒã‚’ä¿å­˜ï¼ˆæ¯”è¼ƒç”¨ï¼‰
                this.beforeCropImage = this.currentImage;
                
                const tempCanvas = document.createElement('canvas');
                const tempCtx = tempCanvas.getContext('2d');
                
                const scaleX = this.currentImage.width / this.canvas.width;
                const scaleY = this.currentImage.height / this.canvas.height;
                
                tempCanvas.width = this.cropArea.width * scaleX;
                tempCanvas.height = this.cropArea.height * scaleY;
                
                tempCtx.drawImage(
                    this.currentImage,
                    this.cropArea.left * scaleX,
                    this.cropArea.top * scaleY,
                    this.cropArea.width * scaleX,
                    this.cropArea.height * scaleY,
                    0, 0,
                    tempCanvas.width,
                    tempCanvas.height
                );
                
                const img = new Image();
                img.onload = () => {
                    this.currentImage = img;
                    this.displayImage(img);
                    this.exitCropMode();
                    this.showComparisonButton();
                };
                img.src = tempCanvas.toDataURL('image/jpeg', this.quality);
            }
            
            cancelCrop() {
                this.exitCropMode();
            }
            
            exitCropMode() {
                this.isCropMode = false;
                this.cropArea = null;
                document.getElementById('cropOverlay').style.display = 'none';
                document.getElementById('cropModeIndicator').classList.remove('active');
                document.getElementById('cropInstructions').classList.remove('active');
                this.canvas.style.cursor = 'default';
                
                // ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ«ãƒœã‚¿ãƒ³ã‚’å‰Šé™¤
                const controlButtons = document.getElementById('cropControlButtons');
                if (controlButtons) {
                    controlButtons.remove();
                }
            }
            
            showComparisonButton() {
                // æ¯”è¼ƒãƒœã‚¿ãƒ³ã‚’è¿½åŠ ï¼ˆã¾ã å­˜åœ¨ã—ãªã„å ´åˆï¼‰
                if (!document.getElementById('compareBtn')) {
                    const toolbar = document.querySelector('.toolbar');
                    const compareBtn = document.createElement('button');
                    compareBtn.id = 'compareBtn';
                    compareBtn.className = 'btn btn-primary';
                    compareBtn.textContent = 'ğŸ”„ å…ƒç”»åƒã¨æ¯”è¼ƒ';
                    compareBtn.onclick = () => this.toggleComparison();
                    toolbar.insertBefore(compareBtn, toolbar.firstChild);
                }
            }
            
            toggleComparison() {
                if (this.beforeCropImage) {
                    if (this.isShowingOriginal) {
                        this.displayImage(this.currentImage);
                        document.getElementById('compareBtn').textContent = 'ğŸ”„ å…ƒç”»åƒã¨æ¯”è¼ƒ';
                    } else {
                        this.displayImage(this.beforeCropImage);
                        document.getElementById('compareBtn').textContent = 'ğŸ“¸ ãƒˆãƒªãƒŸãƒ³ã‚°å¾Œã‚’è¡¨ç¤º';
                    }
                    this.isShowingOriginal = !this.isShowingOriginal;
                }
            }
            
            startSmartCrop10MB() {
                console.log('===== ã‚¹ãƒãƒ¼ãƒˆ10MBãƒˆãƒªãƒŸãƒ³ã‚°é–‹å§‹ =====');
                
                // ãƒˆãƒªãƒŸãƒ³ã‚°ãƒ¢ãƒ¼ãƒ‰ã«å…¥ã‚‹
                this.is10MBMode = true;
                this.isCropMode = true;
                document.getElementById('cropModeIndicator').classList.add('active');
                document.getElementById('cropModeIndicator').innerHTML = 'ğŸ“ 9-10MBãƒˆãƒªãƒŸãƒ³ã‚°ãƒ¢ãƒ¼ãƒ‰';
                
                // 9-10MBã®ç¯„å›²ã‚’è¨ˆç®—ã—ã¦å€™è£œãƒ©ã‚¤ãƒ³ã‚’è¡¨ç¤º
                this.calculate10MBCropSizes();
            }
            
            async calculate10MBCropSizes() {
                console.log('9-10MBã®ç¯„å›²ã§ãƒˆãƒªãƒŸãƒ³ã‚°ã‚µã‚¤ã‚ºã‚’è¨ˆç®—ä¸­...');
                this.showProgressIndicator('9-10MBã®ç¯„å›²ã‚’è¨ˆç®—ä¸­...');
                
                const targetMin = 9 * 1024 * 1024; // 9MB
                const targetMax = 10 * 1024 * 1024; // 10MB
                
                // ç¾åœ¨ã®ç”»åƒã®ã‚¢ã‚¹ãƒšã‚¯ãƒˆæ¯”ã‚’ç¶­æŒ
                const aspectRatio = this.currentImage.width / this.currentImage.height;
                
                // ã¾ãšç¾åœ¨ã®ã‚µã‚¤ã‚ºã§ãƒã‚§ãƒƒã‚¯
                const currentSize = await this.estimateFileSize(this.currentImage.width, this.currentImage.height);
                console.log(`ç¾åœ¨ã®ç”»åƒã‚µã‚¤ã‚º: ${(currentSize / (1024 * 1024)).toFixed(2)}MB`);
                
                // å€™è£œã¨ãªã‚‹ã‚µã‚¤ã‚ºã‚’è¨ˆç®—
                const candidates = [];
                
                if (currentSize < targetMin) {
                    // ç”»åƒãŒå°ã•ã™ãã‚‹å ´åˆã¯æ‹¡å¤§ã‚‚æ¤œè¨
                    console.log('ç”»åƒãŒå°ã•ã„ãŸã‚ã€æ‹¡å¤§ã‚’æ¤œè¨ã—ã¾ã™');
                    const steps = 20;
                    
                    for (let i = 0; i <= steps; i++) {
                        const scale = 1.0 + (3.0 * i / steps); // 100%ã‹ã‚‰400%ã¾ã§
                        const width = Math.round(this.currentImage.width * scale);
                        const height = Math.round(this.currentImage.height * scale);
                        
                        this.updateProgressIndicator(`ã‚µã‚¤ã‚ºè¨ˆç®—ä¸­... (${i + 1}/${steps + 1})`);
                        
                        // ã‚µã‚¤ã‚ºã‚’æ¨å®šï¼ˆå®Ÿéš›ã®ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‰ã§ï¼‰
                        const estimatedSize = await this.estimateFileSize(width, height);
                        console.log(`Scale ${scale.toFixed(2)}: ${width}x${height} = ${(estimatedSize / (1024 * 1024)).toFixed(2)}MB`);
                        
                        if (estimatedSize >= targetMin && estimatedSize <= targetMax) {
                            candidates.push({
                                width: width,
                                height: height,
                                scale: scale,
                                estimatedSize: estimatedSize
                            });
                        }
                        
                        // 10MBã‚’è¶…ãˆãŸã‚‰çµ‚äº†
                        if (estimatedSize > targetMax) break;
                    }
                } else {
                    // é€šå¸¸ã®ã‚¹ã‚±ãƒ¼ãƒ«ç¯„å›²ã§æ¤œç´¢
                    const steps = 10;
                    
                    for (let i = 0; i <= steps; i++) {
                        const scale = 0.5 + (0.5 * i / steps); // 50%ã‹ã‚‰100%ã¾ã§
                        const width = Math.round(this.currentImage.width * scale);
                        const height = Math.round(this.currentImage.height * scale);
                        
                        this.updateProgressIndicator(`ã‚µã‚¤ã‚ºè¨ˆç®—ä¸­... (${i + 1}/${steps + 1})`);
                        
                        // ã‚µã‚¤ã‚ºã‚’æ¨å®šï¼ˆå®Ÿéš›ã®ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‰ã§ï¼‰
                        const estimatedSize = await this.estimateFileSize(width, height);
                        
                        if (estimatedSize >= targetMin && estimatedSize <= targetMax) {
                            candidates.push({
                                width: width,
                                height: height,
                                scale: scale,
                                estimatedSize: estimatedSize
                            });
                        }
                    }
                }
                
                this.hideProgressIndicator();
                
                if (candidates.length > 0) {
                    // æœ€é©ãªã‚µã‚¤ã‚ºã‚’é¸æŠï¼ˆ10MBã«æœ€ã‚‚è¿‘ã„ã‚‚ã®ï¼‰
                    const optimal = candidates.reduce((prev, curr) => {
                        const prevDiff = Math.abs(10 * 1024 * 1024 - prev.estimatedSize);
                        const currDiff = Math.abs(10 * 1024 * 1024 - curr.estimatedSize);
                        return currDiff < prevDiff ? curr : prev;
                    });
                    
                    console.log(`æœ€é©ãªã‚µã‚¤ã‚º: ${optimal.width}x${optimal.height} (ç´„${(optimal.estimatedSize / (1024 * 1024)).toFixed(2)}MB)`);
                    
                    // ãƒˆãƒªãƒŸãƒ³ã‚°æ ã‚’è¡¨ç¤º
                    this.show10MBCropBox(optimal.width, optimal.height);
                } else {
                    // é©åˆ‡ãªã‚µã‚¤ã‚ºãŒè¦‹ã¤ã‹ã‚‰ãªã„å ´åˆã®å¯¾å‡¦
                    if (currentSize < 1024 * 1024) { // 1MBæœªæº€
                        alert('ç”»åƒãŒå°ã•ã™ãã¾ã™ï¼ˆ1MBæœªæº€ï¼‰ã€‚\n9-10MBã«ã™ã‚‹ã«ã¯å“è³ªã‚’ä¿ã£ãŸã¾ã¾å¤§å¹…ãªæ‹¡å¤§ãŒå¿…è¦ã§ã™ãŒã€\nç”»è³ªãŒåŠ£åŒ–ã™ã‚‹å¯èƒ½æ€§ãŒã‚ã‚Šã¾ã™ã€‚');
                    } else {
                        alert('9-10MBã®ç¯„å›²ã§ãƒˆãƒªãƒŸãƒ³ã‚°ã§ãã‚‹ã‚µã‚¤ã‚ºãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã§ã—ãŸã€‚\nç¾åœ¨ã®ã‚µã‚¤ã‚º: ' + (currentSize / (1024 * 1024)).toFixed(2) + 'MB');
                    }
                    this.exit10MBMode();
                }
            }
            
            async estimateFileSize(width, height) {
                // å®Ÿéš›ã®JPEGã‚¨ãƒ³ã‚³ãƒ¼ãƒ‰ã§ã‚µã‚¤ã‚ºã‚’è¨ˆç®—
                const tempCanvas = document.createElement('canvas');
                const tempCtx = tempCanvas.getContext('2d');
                
                tempCanvas.width = width;
                tempCanvas.height = height;
                
                // ç¾åœ¨ã®ç”»åƒã‚’æŒ‡å®šã‚µã‚¤ã‚ºã§æç”»
                tempCtx.drawImage(this.currentImage, 0, 0, width, height);
                
                // Blobã‚’ä½œæˆã—ã¦å®Ÿéš›ã®ã‚µã‚¤ã‚ºã‚’å–å¾—
                return new Promise((resolve) => {
                    tempCanvas.toBlob((blob) => {
                        if (blob) {
                            console.log(`Estimated size for ${width}x${height}: ${(blob.size / (1024 * 1024)).toFixed(2)}MB`);
                            resolve(blob.size);
                        } else {
                            // ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ï¼šç°¡æ˜“è¨ˆç®—
                            const pixels = width * height;
                            const estimatedSize = Math.round(pixels * this.quality * 0.3);
                            console.log(`Fallback estimation for ${width}x${height}: ${(estimatedSize / (1024 * 1024)).toFixed(2)}MB`);
                            resolve(estimatedSize);
                        }
                    }, 'image/jpeg', this.quality);
                });
            }
            
            show10MBCropBox(targetWidth, targetHeight) {
                // æ—¢å­˜ã®ãƒˆãƒªãƒŸãƒ³ã‚°æ ã‚’å‰Šé™¤
                const existingBox = document.getElementById('smartCropBox');
                if (existingBox) {
                    existingBox.remove();
                }
                
                // ã‚­ãƒ£ãƒ³ãƒã‚¹ä¸Šã§ã®ã‚µã‚¤ã‚ºã‚’è¨ˆç®—
                const scaleX = this.canvas.width / this.currentImage.width;
                const scaleY = this.canvas.height / this.currentImage.height;
                const boxWidth = targetWidth * scaleX;
                const boxHeight = targetHeight * scaleY;
                
                // ãƒˆãƒªãƒŸãƒ³ã‚°æ ã‚’ä½œæˆ
                const cropBox = document.createElement('div');
                cropBox.id = 'smartCropBox';
                cropBox.style.cssText = `
                    position: absolute;
                    border: 3px solid #00ff00;
                    background: rgba(0, 255, 0, 0.1);
                    cursor: move;
                    z-index: 100;
                    box-shadow: 0 0 0 9999px rgba(0, 0, 0, 0.5);
                `;
                cropBox.style.width = boxWidth + 'px';
                cropBox.style.height = boxHeight + 'px';
                cropBox.style.left = (this.canvas.width - boxWidth) / 2 + 'px';
                cropBox.style.top = (this.canvas.height - boxHeight) / 2 + 'px';
                
                // ãƒªã‚µã‚¤ã‚ºãƒãƒ³ãƒ‰ãƒ«ã‚’è¿½åŠ 
                const handles = ['nw', 'ne', 'sw', 'se'];
                handles.forEach(pos => {
                    const handle = document.createElement('div');
                    handle.className = `resize-handle ${pos}`;
                    handle.style.cssText = `
                        position: absolute;
                        width: 12px;
                        height: 12px;
                        background: white;
                        border: 2px solid #00ff00;
                        border-radius: 50%;
                    `;
                    
                    if (pos.includes('n')) handle.style.top = '-6px';
                    if (pos.includes('s')) handle.style.bottom = '-6px';
                    if (pos.includes('w')) handle.style.left = '-6px';
                    if (pos.includes('e')) handle.style.right = '-6px';
                    
                    handle.style.cursor = `${pos}-resize`;
                    cropBox.appendChild(handle);
                });
                
                // ã‚µã‚¤ã‚ºè¡¨ç¤ºã‚’è¿½åŠ 
                const sizeLabel = document.createElement('div');
                sizeLabel.id = 'smartCropSizeLabel';
                sizeLabel.style.cssText = `
                    position: absolute;
                    bottom: -30px;
                    left: 50%;
                    transform: translateX(-50%);
                    background: rgba(0, 0, 0, 0.8);
                    color: white;
                    padding: 5px 10px;
                    border-radius: 5px;
                    font-size: 12px;
                    white-space: nowrap;
                `;
                cropBox.appendChild(sizeLabel);
                
                // ã‚­ãƒ£ãƒ³ãƒã‚¹ã‚³ãƒ³ãƒ†ãƒŠã«è¿½åŠ 
                const canvasContainer = document.querySelector('.canvas-container');
                canvasContainer.style.position = 'relative';
                canvasContainer.appendChild(cropBox);
                
                // ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼ã‚’è¿½åŠ 
                this.makeSmartCropBoxDraggable(cropBox);
                this.makeSmartCropBoxResizable(cropBox);
                
                // åˆæœŸã‚µã‚¤ã‚ºã‚’è¡¨ç¤º
                this.updateSmartCropSize(cropBox);
                
                // ç¢ºå®šãƒœã‚¿ãƒ³ã‚’è¡¨ç¤º
                this.showSmartCropButtons();
            }
            
            makeSmartCropBoxDraggable(box) {
                let isDragging = false;
                let startX, startY, initialLeft, initialTop;
                
                const startDrag = (e) => {
                    if (e.target.classList.contains('resize-handle')) return;
                    isDragging = true;
                    startX = e.clientX;
                    startY = e.clientY;
                    initialLeft = box.offsetLeft;
                    initialTop = box.offsetTop;
                    e.preventDefault();
                };
                
                const drag = (e) => {
                    if (!isDragging) return;
                    
                    const dx = e.clientX - startX;
                    const dy = e.clientY - startY;
                    
                    let newLeft = initialLeft + dx;
                    let newTop = initialTop + dy;
                    
                    // å¢ƒç•Œãƒã‚§ãƒƒã‚¯
                    newLeft = Math.max(0, Math.min(newLeft, this.canvas.width - box.offsetWidth));
                    newTop = Math.max(0, Math.min(newTop, this.canvas.height - box.offsetHeight));
                    
                    box.style.left = newLeft + 'px';
                    box.style.top = newTop + 'px';
                    
                    this.updateSmartCropSize(box);
                };
                
                const endDrag = () => {
                    isDragging = false;
                };
                
                box.addEventListener('mousedown', startDrag);
                document.addEventListener('mousemove', drag);
                document.addEventListener('mouseup', endDrag);
            }
            
            makeSmartCropBoxResizable(box) {
                const handles = box.querySelectorAll('.resize-handle');
                
                handles.forEach(handle => {
                    let isResizing = false;
                    let startX, startY, startWidth, startHeight, startLeft, startTop;
                    const pos = handle.className.split(' ')[1];
                    
                    handle.addEventListener('mousedown', (e) => {
                        isResizing = true;
                        startX = e.clientX;
                        startY = e.clientY;
                        startWidth = box.offsetWidth;
                        startHeight = box.offsetHeight;
                        startLeft = box.offsetLeft;
                        startTop = box.offsetTop;
                        e.stopPropagation();
                        e.preventDefault();
                    });
                    
                    document.addEventListener('mousemove', (e) => {
                        if (!isResizing) return;
                        
                        const dx = e.clientX - startX;
                        const dy = e.clientY - startY;
                        
                        let newWidth = startWidth;
                        let newHeight = startHeight;
                        let newLeft = startLeft;
                        let newTop = startTop;
                        
                        // ã‚¢ã‚¹ãƒšã‚¯ãƒˆæ¯”ã‚’ç¶­æŒ
                        const aspectRatio = this.currentImage.width / this.currentImage.height;
                        
                        if (pos.includes('e')) {
                            newWidth = startWidth + dx;
                            newHeight = newWidth / aspectRatio;
                        }
                        if (pos.includes('w')) {
                            newWidth = startWidth - dx;
                            newHeight = newWidth / aspectRatio;
                            newLeft = startLeft + dx;
                            newTop = startTop + (startHeight - newHeight);
                        }
                        if (pos.includes('s')) {
                            newHeight = startHeight + dy;
                            newWidth = newHeight * aspectRatio;
                        }
                        if (pos.includes('n')) {
                            newHeight = startHeight - dy;
                            newWidth = newHeight * aspectRatio;
                            newTop = startTop + dy;
                            newLeft = startLeft + (startWidth - newWidth);
                        }
                        
                        // æœ€å°ã‚µã‚¤ã‚ºåˆ¶é™
                        if (newWidth > 50 && newHeight > 50) {
                            box.style.width = newWidth + 'px';
                            box.style.height = newHeight + 'px';
                            box.style.left = newLeft + 'px';
                            box.style.top = newTop + 'px';
                            
                            this.updateSmartCropSize(box);
                        }
                    });
                    
                    document.addEventListener('mouseup', () => {
                        isResizing = false;
                    });
                });
            }
            
            async updateSmartCropSize(box) {
                // ã‚­ãƒ£ãƒ³ãƒã‚¹åº§æ¨™ã‹ã‚‰å®Ÿéš›ã®ç”»åƒåº§æ¨™ã«å¤‰æ›
                const scaleX = this.currentImage.width / this.canvas.width;
                const scaleY = this.currentImage.height / this.canvas.height;
                
                const actualWidth = Math.round(box.offsetWidth * scaleX);
                const actualHeight = Math.round(box.offsetHeight * scaleY);
                
                // ãƒ©ãƒ™ãƒ«ã‚’ä¸€æ™‚çš„ã«æ›´æ–°
                const label = box.querySelector('#smartCropSizeLabel');
                if (label) {
                    label.textContent = `${actualWidth}Ã—${actualHeight} (è¨ˆç®—ä¸­...)`;
                }
                
                // ãƒ•ã‚¡ã‚¤ãƒ«ã‚µã‚¤ã‚ºã‚’æ¨å®šï¼ˆéåŒæœŸï¼‰
                const estimatedSize = await this.estimateFileSize(actualWidth, actualHeight);
                const sizeInMB = (estimatedSize / (1024 * 1024)).toFixed(2);
                
                // ãƒ©ãƒ™ãƒ«ã‚’æ›´æ–°
                if (label) {
                    label.textContent = `${actualWidth}Ã—${actualHeight} (ç´„${sizeInMB}MB)`;
                    
                    // ã‚µã‚¤ã‚ºã«å¿œã˜ã¦è‰²ã‚’å¤‰æ›´
                    if (estimatedSize >= 9 * 1024 * 1024 && estimatedSize <= 10 * 1024 * 1024) {
                        box.style.borderColor = '#00ff00';
                        label.style.background = 'rgba(0, 255, 0, 0.8)';
                    } else if (estimatedSize < 9 * 1024 * 1024) {
                        box.style.borderColor = '#ffff00';
                        label.style.background = 'rgba(255, 255, 0, 0.8)';
                    } else {
                        box.style.borderColor = '#ff0000';
                        label.style.background = 'rgba(255, 0, 0, 0.8)';
                    }
                }
                
                // ç¾åœ¨ã®è¨­å®šã‚’ä¿å­˜
                this.smartCropArea = {
                    left: box.offsetLeft,
                    top: box.offsetTop,
                    width: box.offsetWidth,
                    height: box.offsetHeight,
                    actualWidth: actualWidth,
                    actualHeight: actualHeight,
                    estimatedSize: estimatedSize
                };
            }
            
            showSmartCropButtons() {
                // æ—¢å­˜ã®ãƒœã‚¿ãƒ³ã‚’å‰Šé™¤
                const existingButtons = document.getElementById('smartCropButtons');
                if (existingButtons) {
                    existingButtons.remove();
                }
                
                const buttonsDiv = document.createElement('div');
                buttonsDiv.id = 'smartCropButtons';
                buttonsDiv.style.cssText = `
                    position: fixed;
                    bottom: 140px;
                    left: 50%;
                    transform: translateX(-50%);
                    display: flex;
                    gap: 15px;
                    z-index: 1001;
                `;
                
                const confirmBtn = document.createElement('button');
                confirmBtn.textContent = 'âœ‚ï¸ ã“ã®ã‚µã‚¤ã‚ºã§ãƒˆãƒªãƒŸãƒ³ã‚°';
                confirmBtn.className = 'btn btn-success';
                confirmBtn.onclick = () => this.confirmSmartCrop();
                
                const cancelBtn = document.createElement('button');
                cancelBtn.textContent = 'âŒ ã‚­ãƒ£ãƒ³ã‚»ãƒ«';
                cancelBtn.className = 'btn btn-secondary';
                cancelBtn.onclick = () => this.exit10MBMode();
                
                buttonsDiv.appendChild(confirmBtn);
                buttonsDiv.appendChild(cancelBtn);
                document.body.appendChild(buttonsDiv);
                
                // èª¬æ˜ã‚’è¡¨ç¤º
                const instructions = document.getElementById('cropInstructions');
                instructions.innerHTML = 'ğŸ“ ç·‘ã®æ ã‚’ãƒ‰ãƒ©ãƒƒã‚°ã—ã¦ç§»å‹•ã€è§’ã‚’ãƒ‰ãƒ©ãƒƒã‚°ã—ã¦ã‚µã‚¤ã‚ºèª¿æ•´<br>9-10MBã®ç¯„å›²ã§è‡ªç”±ã«èª¿æ•´ã§ãã¾ã™';
                instructions.classList.add('active');
            }
            
            confirmSmartCrop() {
                if (!this.smartCropArea) return;
                
                console.log(`ã‚¹ãƒãƒ¼ãƒˆã‚¯ãƒ­ãƒƒãƒ—å®Ÿè¡Œ: ${this.smartCropArea.actualWidth}x${this.smartCropArea.actualHeight}`);
                
                // å…ƒç”»åƒã‚’ä¿å­˜
                this.beforeCropImage = this.currentImage;
                
                const tempCanvas = document.createElement('canvas');
                const tempCtx = tempCanvas.getContext('2d');
                
                const scaleX = this.currentImage.width / this.canvas.width;
                const scaleY = this.currentImage.height / this.canvas.height;
                
                tempCanvas.width = this.smartCropArea.actualWidth;
                tempCanvas.height = this.smartCropArea.actualHeight;
                
                tempCtx.drawImage(
                    this.currentImage,
                    this.smartCropArea.left * scaleX,
                    this.smartCropArea.top * scaleY,
                    this.smartCropArea.width * scaleX,
                    this.smartCropArea.height * scaleY,
                    0, 0,
                    tempCanvas.width,
                    tempCanvas.height
                );
                
                const img = new Image();
                img.onload = () => {
                    this.currentImage = img;
                    this.displayImage(img);
                    this.exit10MBMode();
                    this.showComparisonButton();
                    
                    const sizeInMB = (this.smartCropArea.estimatedSize / (1024 * 1024)).toFixed(2);
                    alert(`ç”»åƒã‚’ç´„${sizeInMB}MBã«ãƒˆãƒªãƒŸãƒ³ã‚°ã—ã¾ã—ãŸï¼`);
                };
                img.src = tempCanvas.toDataURL('image/jpeg', this.quality);
            }
            
            exit10MBMode() {
                this.is10MBMode = false;
                this.isCropMode = false;
                this.smartCropArea = null;
                
                document.getElementById('cropModeIndicator').classList.remove('active');
                document.getElementById('cropInstructions').classList.remove('active');
                
                const smartCropBox = document.getElementById('smartCropBox');
                if (smartCropBox) {
                    smartCropBox.remove();
                }
                
                const buttons = document.getElementById('smartCropButtons');
                if (buttons) {
                    buttons.remove();
                }
            }
            
            async cropTo10MB() {
                console.log('===== 10MBãƒˆãƒªãƒŸãƒ³ã‚°å‡¦ç†é–‹å§‹ =====');
                const startTime = performance.now();
                
                // ãƒ—ãƒ­ã‚°ãƒ¬ã‚¹è¡¨ç¤ºã‚’ä½œæˆ
                this.showProgressIndicator('10MBã«æœ€é©åŒ–ä¸­...');
                
                const targetSize = 10 * 1024 * 1024; // 10MB in bytes
                console.log(`ç›®æ¨™ã‚µã‚¤ã‚º: ${(targetSize / (1024 * 1024)).toFixed(2)}MB`);
                console.log(`ç¾åœ¨ã®ç”»åƒã‚µã‚¤ã‚º: ${this.currentImage.width}x${this.currentImage.height}`);
                
                let scale = 1;
                let quality = this.quality;
                let attempts = 0;
                const maxAttempts = 20;
                let lastEstimatedSize = 0;
                
                console.log(`åˆæœŸè¨­å®š - Scale: ${scale}, Quality: ${quality}`);
                
                while (attempts < maxAttempts) {
                    console.log(`\n--- è©¦è¡Œ ${attempts + 1}/${maxAttempts} ---`);
                    
                    const tempCanvas = document.createElement('canvas');
                    const tempCtx = tempCanvas.getContext('2d');
                    
                    tempCanvas.width = Math.round(this.currentImage.width * scale);
                    tempCanvas.height = Math.round(this.currentImage.height * scale);
                    
                    console.log(`Canvas ã‚µã‚¤ã‚º: ${tempCanvas.width}x${tempCanvas.height}`);
                    console.log(`Scale: ${scale.toFixed(3)}, Quality: ${quality.toFixed(3)}`);
                    
                    tempCtx.drawImage(this.currentImage, 0, 0, tempCanvas.width, tempCanvas.height);
                    
                    const dataUrl = tempCanvas.toDataURL('image/jpeg', quality);
                    const base64 = dataUrl.split(',')[1];
                    const estimatedSize = base64.length * 0.75;
                    
                    console.log(`æ¨å®šã‚µã‚¤ã‚º: ${(estimatedSize / (1024 * 1024)).toFixed(2)}MB`);
                    console.log(`ç›®æ¨™ã¨ã®å·®: ${((estimatedSize - targetSize) / (1024 * 1024)).toFixed(2)}MB`);
                    console.log(`èª¤å·®ç‡: ${(Math.abs(estimatedSize - targetSize) / targetSize * 100).toFixed(1)}%`);
                    
                    // ãƒ—ãƒ­ã‚°ãƒ¬ã‚¹æ›´æ–°
                    this.updateProgressIndicator(
                        `æœ€é©åŒ–ä¸­... (${attempts + 1}/${maxAttempts})<br>` +
                        `ç¾åœ¨: ${(estimatedSize / (1024 * 1024)).toFixed(2)}MB / ç›®æ¨™: 10MB`
                    );
                    
                    if (Math.abs(estimatedSize - targetSize) < targetSize * 0.05) {
                        // 5%ä»¥å†…ã®èª¤å·®ãªã‚‰å®Œäº†
                        console.log('âœ… ç›®æ¨™ã‚µã‚¤ã‚ºã«åˆ°é”ï¼');
                        const img = new Image();
                        img.onload = () => {
                            this.currentImage = img;
                            this.displayImage(img);
                            const endTime = performance.now();
                            console.log(`å‡¦ç†å®Œäº†ï¼ æ‰€è¦æ™‚é–“: ${((endTime - startTime) / 1000).toFixed(2)}ç§’`);
                            console.log('===== 10MBãƒˆãƒªãƒŸãƒ³ã‚°å‡¦ç†çµ‚äº† =====\n');
                            this.hideProgressIndicator();
                            alert(`ç”»åƒã‚’ç´„10MB (${(estimatedSize / (1024 * 1024)).toFixed(2)}MB) ã«æœ€é©åŒ–ã—ã¾ã—ãŸï¼`);
                        };
                        img.src = dataUrl;
                        break;
                    }
                    
                    // åæŸã—ã¦ã„ãªã„å ´åˆã®è­¦å‘Š
                    if (attempts > 5 && Math.abs(lastEstimatedSize - estimatedSize) < 1024) {
                        console.warn('âš ï¸ ã‚µã‚¤ã‚ºãŒåæŸã—ãªã„å¯èƒ½æ€§ãŒã‚ã‚Šã¾ã™');
                    }
                    lastEstimatedSize = estimatedSize;
                    
                    if (estimatedSize > targetSize) {
                        const oldScale = scale;
                        const oldQuality = quality;
                        
                        scale *= 0.9;
                        if (scale < 0.1) {
                            quality *= 0.9;
                            scale = 0.1;
                        }
                        
                        console.log(`ğŸ“‰ ã‚µã‚¤ã‚ºã‚’ç¸®å°: Scale ${oldScale.toFixed(3)} â†’ ${scale.toFixed(3)}, Quality ${oldQuality.toFixed(3)} â†’ ${quality.toFixed(3)}`);
                    } else {
                        const oldScale = scale;
                        const oldQuality = quality;
                        
                        scale *= 1.05;
                        if (scale > 1) {
                            scale = 1;
                            quality = Math.min(quality * 1.1, 1);
                        }
                        
                        console.log(`ğŸ“ˆ ã‚µã‚¤ã‚ºã‚’æ‹¡å¤§: Scale ${oldScale.toFixed(3)} â†’ ${scale.toFixed(3)}, Quality ${oldQuality.toFixed(3)} â†’ ${quality.toFixed(3)}`);
                    }
                    
                    attempts++;
                }
                
                if (attempts >= maxAttempts) {
                    console.error('âŒ æœ€å¤§è©¦è¡Œå›æ•°ã«åˆ°é”ã€‚å‡¦ç†ã‚’ä¸­æ­¢ã—ã¾ã—ãŸã€‚');
                    this.hideProgressIndicator();
                    alert('10MBã¸ã®æœ€é©åŒ–ã«å¤±æ•—ã—ã¾ã—ãŸã€‚ç”»åƒãŒå°ã•ã™ãã‚‹ã‹ã€å¤§ãã™ãã‚‹å¯èƒ½æ€§ãŒã‚ã‚Šã¾ã™ã€‚');
                }
                
                const endTime = performance.now();
                console.log(`ç·å‡¦ç†æ™‚é–“: ${((endTime - startTime) / 1000).toFixed(2)}ç§’`);
                console.log('===== 10MBãƒˆãƒªãƒŸãƒ³ã‚°å‡¦ç†çµ‚äº† =====\n');
            }
            
            showProgressIndicator(message) {
                // æ—¢å­˜ã®ã‚¤ãƒ³ã‚¸ã‚±ãƒ¼ã‚¿ãƒ¼ã‚’å‰Šé™¤
                const existing = document.getElementById('progressIndicator');
                if (existing) {
                    existing.remove();
                }
                
                const indicator = document.createElement('div');
                indicator.id = 'progressIndicator';
                indicator.style.cssText = `
                    position: fixed;
                    top: 50%;
                    left: 50%;
                    transform: translate(-50%, -50%);
                    background: rgba(0, 0, 0, 0.9);
                    color: white;
                    padding: 30px 40px;
                    border-radius: 15px;
                    font-size: 16px;
                    z-index: 10000;
                    text-align: center;
                    box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
                `;
                indicator.innerHTML = `
                    <div style="margin-bottom: 15px;">â³</div>
                    <div>${message}</div>
                `;
                document.body.appendChild(indicator);
            }
            
            updateProgressIndicator(message) {
                const indicator = document.getElementById('progressIndicator');
                if (indicator) {
                    indicator.innerHTML = `
                        <div style="margin-bottom: 15px;">â³</div>
                        <div>${message}</div>
                    `;
                }
            }
            
            hideProgressIndicator() {
                const indicator = document.getElementById('progressIndicator');
                if (indicator) {
                    indicator.remove();
                }
            }
            
            resizeCanvas() {
                const width = parseInt(document.getElementById('widthInput').value) || 100;
                const height = parseInt(document.getElementById('heightInput').value) || 100;
                
                console.log(`Resizing image to: ${width}x${height}`);
                
                const tempCanvas = document.createElement('canvas');
                const tempCtx = tempCanvas.getContext('2d');
                
                tempCanvas.width = width;
                tempCanvas.height = height;
                tempCtx.drawImage(this.currentImage, 0, 0, width, height);
                
                // æ–°ã—ã„Imageã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ä½œæˆã—ã¦ã‚µã‚¤ã‚ºã‚’æ­£ã—ãè¨­å®š
                tempCanvas.toBlob((blob) => {
                    const url = URL.createObjectURL(blob);
                    const img = new Image();
                    img.onload = () => {
                        this.currentImage = img;
                        this.displayImage(img);
                        URL.revokeObjectURL(url);
                    };
                    img.src = url;
                }, 'image/jpeg', this.quality);
            }
            
            updateSizeDisplay() {
                if (!this.currentImage) return;
                
                // ãƒ‡ãƒãƒƒã‚°ãƒ­ã‚°
                console.log('updateSizeDisplay called');
                console.log(`Canvas size: ${this.canvas.width}x${this.canvas.height}`);
                console.log(`Image size: ${this.currentImage.width}x${this.currentImage.height}`);
                console.log(`Quality: ${this.quality}`);
                
                // å®Ÿéš›ã®ç”»åƒã‚µã‚¤ã‚ºã§Blobã‚’ä½œæˆ
                const tempCanvas = document.createElement('canvas');
                const tempCtx = tempCanvas.getContext('2d');
                
                // å…ƒç”»åƒã®ã‚µã‚¤ã‚ºã‚’ä½¿ç”¨
                tempCanvas.width = this.currentImage.width;
                tempCanvas.height = this.currentImage.height;
                tempCtx.drawImage(this.currentImage, 0, 0);
                
                tempCanvas.toBlob((blob) => {
                    if (!blob) {
                        console.error('Blob creation failed');
                        return;
                    }
                    
                    const sizeInBytes = blob.size;
                    const sizeInKB = sizeInBytes / 1024;
                    const sizeInMB = sizeInKB / 1024;
                    
                    console.log(`Blob size: ${sizeInBytes} bytes = ${sizeInKB.toFixed(2)} KB = ${sizeInMB.toFixed(2)} MB`);
                    
                    // ã‚µã‚¤ã‚ºè¡¨ç¤ºã‚’æ›´æ–°
                    let sizeText;
                    if (sizeInMB >= 1) {
                        sizeText = `${sizeInMB.toFixed(2)} MB`;
                    } else if (sizeInKB >= 1) {
                        sizeText = `${sizeInKB.toFixed(2)} KB`;
                    } else {
                        sizeText = `${sizeInBytes} bytes`;
                    }
                    
                    document.getElementById('currentSize').textContent = sizeText;
                    
                    // ãƒ—ãƒ­ã‚°ãƒ¬ã‚¹ãƒãƒ¼ã®æ›´æ–°ï¼ˆ10MBã‚’åŸºæº–ï¼‰
                    const percentage = Math.min((sizeInBytes / (10 * 1024 * 1024)) * 100, 100);
                    document.getElementById('sizeProgressBar').style.width = `${percentage}%`;
                    
                    // ãƒ—ãƒ­ã‚°ãƒ¬ã‚¹ãƒãƒ¼ã®è‰²ã‚’æ›´æ–°
                    const progressBar = document.getElementById('sizeProgressBar');
                    if (sizeInMB > 10.5) {
                        progressBar.style.background = '#dc3545'; // èµ¤
                    } else if (sizeInMB > 9.5 && sizeInMB <= 10.5) {
                        progressBar.style.background = '#28a745'; // ç·‘
                    } else {
                        progressBar.style.background = '#ffc107'; // é»„
                    }
                    
                    // è§£åƒåº¦è¡¨ç¤ºï¼ˆå®Ÿéš›ã®ç”»åƒã‚µã‚¤ã‚ºï¼‰
                    document.getElementById('resolution').textContent = 
                        `${this.currentImage.width} x ${this.currentImage.height}`;
                }, 'image/jpeg', this.quality);
            }
            
            updateCropSizeDisplay() {
                if (!this.cropArea) return;
                
                const scaleX = this.currentImage.width / this.canvas.width;
                const scaleY = this.currentImage.height / this.canvas.height;
                
                const actualWidth = Math.round(this.cropArea.width * scaleX);
                const actualHeight = Math.round(this.cropArea.height * scaleY);
                
                document.getElementById('resolution').textContent = 
                    `${actualWidth} x ${actualHeight} (é¸æŠä¸­)`;
            }
            
            downloadImage() {
                this.canvas.toBlob((blob) => {
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = `trimmed_image_${Date.now()}.jpg`;
                    a.click();
                    URL.revokeObjectURL(url);
                }, 'image/jpeg', this.quality);
            }
            
            resetImage() {
                if (this.originalImage) {
                    this.currentImage = this.originalImage;
                    this.beforeCropImage = null;
                    this.isShowingOriginal = false;
                    this.displayImage(this.originalImage);
                    this.exitCropMode();
                    
                    // æ¯”è¼ƒãƒœã‚¿ãƒ³ã‚’å‰Šé™¤
                    const compareBtn = document.getElementById('compareBtn');
                    if (compareBtn) {
                        compareBtn.remove();
                    }
                }
            }
            
            selectNewImage() {
                this.hideEditor();
                this.originalImage = null;
                this.currentImage = null;
                this.cropArea = null;
                document.getElementById('fileInput').value = '';
            }
        }
        
        // ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³åˆæœŸåŒ–
        const trimmer = new ImageTrimmer();
    </script>
</body>
</html>